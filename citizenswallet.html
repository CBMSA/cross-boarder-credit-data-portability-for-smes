
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Sadicoin Wallet (Prototype with FX + Transactions + MoonPay API)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: Arial, sans-serif; background: #f6f9fc; margin: 0; padding: 20px; }
    h1 { color: #2a4d8f; }
    .box { background: #fff; padding: 20px; margin: 15px auto; max-width: 720px; border-radius: 10px; box-shadow: 0 3px 6px rgba(0,0,0,0.1); }
    input, button, select { width: 100%; margin: 6px 0; padding: 10px; font-size: 14px; }
    button { background: #2a4d8f; color: #fff; border: none; border-radius: 6px; cursor: pointer; }
    button:hover { background: #1c3360; }
    pre { background: #eef6ff; padding: 10px; border-radius: 6px; font-size: 13px; white-space: pre-wrap; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 13px; }
    th, td { border: 1px solid #ccc; padding: 6px; text-align: left; }
    th { background: #f0f4f9; }
    .row { display:flex; gap:10px; }
    .col { flex:1; }
    .small { font-size:12px; color:#666; margin-top:6px; }
  </style>
</head>
<body>
  <h1>ðŸ’³ Sadicoin Wallet Prototype</h1>

  <!-- MetaMask / Wallet Connect -->
  <div class="box">
    <h3>Connect Wallet</h3>
    <div class="row">
      <div class="col">
        <button id="btn_connect" onclick="connectWallet()">Connect MetaMask</button>
      </div>
      <div class="col">
        <button onclick="disconnectLocal()">Logout (local)</button>
      </div>
    </div>
    <div class="small">Connected account: <span id="connected_addr">none</span></div>
    <div class="small">Network: <span id="network_name">â€”</span></div>
  </div>

  <!-- Register -->
  <div class="box">
    <h3>Register</h3>
    <input id="r_name" placeholder="Name">
    <input id="r_email" placeholder="Email">
    <input id="r_phone" placeholder="Phone">
    <input id="r_pass" placeholder="Password" type="password">
    <button onclick="register()">Register (Get USD 200)</button>
  </div>

  <!-- Login -->
  <div class="box">
    <h3>Login</h3>
    <input id="l_email" placeholder="Email">
    <input id="l_pass" placeholder="Password" type="password">
    <button onclick="login()">Login</button>
  </div>

  <!-- Wallet -->
  <div class="box">
    <h3>Wallet</h3>
    <label>Show balance in:</label>
    <select id="fx_currency" onchange="refreshWallet()"></select>
    <pre id="wallet_info">Not logged in</pre>
    <button onclick="refreshWallet()">Refresh</button>
    <div class="small">ETH Balance: <span id="eth_balance">â€”</span> | SADI Balance: <span id="sadi_balance">â€”</span></div>
  </div>

  <!-- Send -->
  <div class="box">
    <h3>Send SADI</h3>
    <input id="to_addr" placeholder="Recipient address (0x...)">
    <input id="to_amt" placeholder="Amount (SADI)" type="number" step="any">
    <button onclick="sendToken()">Send SADI</button>
    <pre id="send_res"></pre>
  </div>

  <!-- Transactions -->
  <div class="box">
    <h3>Transaction History (local)</h3>
    <table id="tx_table">
      <thead><tr><th>ID</th><th>To</th><th>Amount</th><th>Date</th><th>PDF</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- MoonPay Swap -->
  <div class="box">
    <h3>MoonPay</h3>
    <div class="row">
      <div class="col"><button onclick="openMoonPayBuy()">Buy (On-ramp) via MoonPay</button></div>
      <div class="col"><button onclick="openMoonPaySell()">Sell (Off-ramp) â€” backend required</button></div>
    </div>
    <div class="small">Note: For secure off-ramp you should implement backend-assisted MoonPay flow.</div>
  </div>

  <!-- jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- ethers.js -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.min.js" integrity="" crossorigin="anonymous"></script>

  <script>
    // --------------- CONFIG (replace placeholders) ----------------
    const CONTRACT_ADDRESS = "0xREPLACE_WITH_DEPLOYED_CONTRACT_ADDRESS"; // <-- set after deploy
    const MOONPAY_PUBLIC_KEY = "pk_live_0UYBzlsyM4A3Adj47IQrOkRx6dCWB4k"; // replace with your public key
    const TOKEN_DECIMALS = 18; // SADI decimals

    // Minimal ABI: ERC20 balanceOf, transfer, name, symbol, decimals
    const ERC20_ABI = [
      "function name() view returns (string)",
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
      "function balanceOf(address) view returns (uint256)",
      "function transfer(address to, uint256 amount) returns (bool)",
      "event Transfer(address indexed from, address indexed to, uint256 value)"
    ];

    // --------------- Local storage keys & state ----------------
    const USERS_KEY = "sadi_users";
    const TXS_KEY = "sadi_txs";
    let currentUser = null;

    let provider = null;
    let signer = null;
    let tokenContract = null;
    let connectedAddress = null;

    const currencySymbols = ["USD","ZAR","BWP","MZN","XDR","XAU"];
    const eodhdToken = "67b2d451e5b8a8.90504186";
    let fxRates = {};

    // ----------------- Helpers -----------------
    function getUsers(){ return JSON.parse(localStorage.getItem(USERS_KEY)||"{}"); }
    function saveUsers(u){ localStorage.setItem(USERS_KEY, JSON.stringify(u)); }
    function getTxs(){ return JSON.parse(localStorage.getItem(TXS_KEY)||"[]"); }
    function saveTxs(t){ localStorage.setItem(TXS_KEY, JSON.stringify(t)); }

    // ----------------- Register/Login -----------------
    function register(){
      const name=r_name.value,email=r_email.value,phone=r_phone.value,password=r_pass.value;
      if(!name||!email||!phone||!password) return alert("Fill all fields");
      let u=getUsers();
      if(u[email]) return alert("User exists!");
      const wallet={ address:"0x"+Math.random().toString(16).substr(2,40), balance:200 }; // USD 200 local
      u[email]={name,email,phone,password,wallet};
      saveUsers(u);
      alert("Registered! You got USD 200.");
    }

    function login(){
      const email=l_email.value,password=l_pass.value;
      let u=getUsers();
      if(!u[email]||u[email].password!==password) return alert("Invalid credentials");
      currentUser=email;
      refreshWallet();
      refreshTxTable();
      alert("Logged in as "+u[email].name);
    }

    function disconnectLocal(){
      currentUser=null;
      wallet_info.innerText="Not logged in";
      connected_addr.innerText = "none";
    }

    // ---------------- FX Rates ----------------
    async function loadRates(){
      try{
        const resp=await fetch(
          `https://eodhd.com/api/real-time/USDZAR.FOREX,USDBWP.FOREX,USDMZN.FOREX,USDXDR.FOREX,USDXAU.FOREX?api_token=${eodhdToken}&fmt=json`
        );
        const data=await resp.json();
        fxRates={USD:1};
        data.forEach(it=>{
          if(it.code && it.code.startsWith("USD")){
            const cur=it.code.replace("USD","").replace(".FOREX","");
            fxRates[cur]=it.close;
          }
        });
      }catch(e){
        console.warn("FX API failed",e);
        fxRates={USD:1,ZAR:19,BWP:13,MZN:63,XDR:0.72,XAU:0.00057};
      }
      const sel=document.getElementById("fx_currency");
      sel.innerHTML=currencySymbols.map(c=>
        `<option value="${c}">${c} (${fxRates[c]||'n/a'})</option>`
      ).join("");
      refreshWallet();
    }

    // ---------------- MetaMask / Ethers ----------------
    async function connectWallet(){
      if (!window.ethereum) return alert("MetaMask not detected. Install MetaMask and try again.");
      try {
        await window.ethereum.request({ method: "eth_requestAccounts" });
        provider = new ethers.BrowserProvider(window.ethereum);
        signer = await provider.getSigner();
        connectedAddress = await signer.getAddress();
        connected_addr.innerText = connectedAddress;
        const network = await provider.getNetwork();
        network_name.innerText = network.name + " (" + network.chainId + ")";
        // instantiate token contract
        tokenContract = new ethers.Contract(CONTRACT_ADDRESS, ERC20_ABI, signer);
        // start watchers
        watchTokenTransfers();
        await updateBalances();
      } catch (err) {
        console.error(err);
        alert("Connection failed: " + err.message);
      }
    }

    // Update ETH and SADI balances
    async function updateBalances(){
      if(!connectedAddress) return;
      try {
        const ethBalance = await provider.getBalance(connectedAddress);
        const ethStr = ethers.formatEther(ethBalance) + " ETH";
        eth_balance.innerText = ethStr;
      } catch(e) {
        eth_balance.innerText = "n/a";
      }

      try {
        if(tokenContract){
          const raw = await tokenContract.balanceOf(connectedAddress);
          const formatted = ethers.formatUnits(raw, TOKEN_DECIMALS);
          sadi_balance.innerText = formatted + " SADI";
        } else {
          sadi_balance.innerText = "contract not set";
        }
      } catch(e){
        sadi_balance.innerText = "n/a";
      }
    }

    // Send SADI tokens
    async function sendToken(){
      if(!connectedAddress) return alert("Connect MetaMask first");
      const to = to_addr.value;
      const amt = to_amt.value;
      if(!to || !amt) return alert("Fill fields");
      try {
        const amtWei = ethers.parseUnits(amt.toString(), TOKEN_DECIMALS);
        const tx = await tokenContract.transfer(to, amtWei);
        send_res.innerText = "Pending tx: " + tx.hash;
        await tx.wait();
        send_res.innerText = "Sent! Tx: " + tx.hash;
        // Add to local txs (prototype)
        const txId = "ONCHAIN-" + Math.floor(Date.now()/1000);
        const txRec = { id: txId, from: connectedAddress, to, amount: parseFloat(amt), date: new Date().toLocaleString() };
        const txs = getTxs(); txs.push(txRec); saveTxs(txs);
        refreshTxTable();
        updateBalances();
        generatePDF(txRec);
      } catch (err) {
        console.error(err);
        alert("Send failed: " + (err && err.message ? err.message : err));
      }
    }

    // Watch token Transfer events to refresh balance automatically
    function watchTokenTransfers(){
      if(!tokenContract) return;
      tokenContract.on("Transfer", (from, to, value, event) => {
        // refresh if connected address involved
        if (from.toLowerCase() === connectedAddress.toLowerCase() || to.toLowerCase() === connectedAddress.toLowerCase()) {
          setTimeout(updateBalances, 1500);
        }
      });
    }

    // ---------------- Transactions Table + PDF ----------------
    function refreshTxTable(){
      let txs=getTxs();
      let body=document.querySelector("#tx_table tbody");
      body.innerHTML=txs.map(t=>
        `<tr><td>${t.id}</td><td>${t.to}</td><td>${t.amount}</td><td>${t.date}</td><td><button onclick='(${generatePDF.toString()})(${JSON.stringify(t)})'>PDF</button></td></tr>`
      ).join("");
    }

    function generatePDF(tx){
      const {jsPDF}=window.jspdf;
      const doc=new jsPDF();
      doc.text("Sadicoin Transaction Receipt",20,20);
      doc.text(`TxID: ${tx.id}`,20,40);
      if(tx.from) doc.text(`From: ${tx.from}`,20,50);
      doc.text(`To: ${tx.to}`,20,60);
      doc.text(`Amount: ${tx.amount}`,20,70);
      doc.text(`Date: ${tx.date}`,20,80);
      doc.save(`${tx.id}.pdf`);
    }

    // ---------------- MoonPay Integration (frontend fallback) ----------------
    function openMoonPayBuy(){
      if(!connectedAddress) return alert("Connect MetaMask first");
      // Frontend direct buy link (public-key flow)
      // Replace currencyCode and baseCurrencyAmount as needed
      const usdAmount = prompt("Enter USD amount to buy (frontend fallback):", "50");
      if(!usdAmount) return;
      const url = `https://buy.moonpay.com?apiKey=${encodeURIComponent(MOONPAY_PUBLIC_KEY)}&currencyCode=ethereum&walletAddress=${encodeURIComponent(connectedAddress)}&baseCurrencyAmount=${encodeURIComponent(usdAmount)}`;
      window.open(url, "_blank");
    }

    function openMoonPaySell(){
      // Sell/off-ramp via MoonPay requires backend / KYC flow; provide guidance
      alert("Off-ramp / Sell requires a server-side (backend) integration with MoonPay to create signed ephemeral tokens and handle KYC callbacks. Implement /api/moonpay/sell on your backend and open the returned URL here.");
      // Example frontend pattern (backend-assisted):
      // fetch(`/api/moonpay/sell?address=${connectedAddress}`).then(r=>r.json()).then(d=>window.open(d.url))
    }

    // ---------------- Fallback: link to backend-assisted buy if available ----------------
    async function openSwap(){
      if(!currentUser) return alert("Login first");
      try {
        const res = await fetch(`/api/moonpay-url?currency=usd&address=${encodeURIComponent(currentUser)}`);
        if (!res.ok) throw new Error("Backend MoonPay not available");
        const data = await res.json();
        window.open(data.url, "_blank");
      } catch (err) {
        console.warn("Backend MoonPay failed, falling back:", err);
        openMoonPayBuy();
      }
    }

    // ---------------- Init & periodic updates ----------------
    async function refreshWallet(){
      if(!currentUser) return wallet_info.innerText="Not logged in";
      let u=getUsers()[currentUser];
      let balanceUSD=u.wallet.balance.toFixed(2);
      let cur=document.getElementById("fx_currency").value||"ZAR";
      let rate=fxRates[cur]||0;
      let balanceLocal = rate ? (u.wallet.balance*rate).toFixed(2) : "n/a";
      wallet_info.innerText=`Address: ${u.wallet.address}\nBalance: USD ${balanceUSD}\n${cur} â‰ˆ ${balanceLocal}`;
    }

    // When connected, also refresh balances
    setInterval(() => {
      if (connectedAddress) updateBalances();
    }, 15_000);

    loadRates();
    setInterval(loadRates,1000*60*5);
    refreshTxTable();

    // Attempt to auto-detect MetaMask connection and address (non-invasive)
    (async function tryAutoConnect() {
      if(window.ethereum && window.ethereum.selectedAddress) {
        try {
          provider = new ethers.BrowserProvider(window.ethereum);
          signer = await provider.getSigner();
          connectedAddress = await signer.getAddress();
          connected_addr.innerText = connectedAddress;
          tokenContract = new ethers.Contract(CONTRACT_ADDRESS, ERC20_ABI, signer);
          updateBalances();
          watchTokenTransfers();
        } catch(e) {
          // ignore
        }
      }
    })();

    // Add small helper to detect network/account changes
    if (window.ethereum) {
      window.ethereum.on && window.ethereum.on('accountsChanged', (accounts) => {
        if (accounts.length === 0) {
          connected_addr.innerText = "none";
          connectedAddress = null;
        } else {
          connected_addr.innerText = accounts[0];
          connectedAddress = accounts[0];
          updateBalances();
        }
      });
      window.ethereum.on && window.ethereum.on('chainChanged', (chainId) => {
        network_name.innerText = chainId;
      });
    }
  </script>
</body>
</html>
