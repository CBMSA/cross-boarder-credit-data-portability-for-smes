
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SadiCoin Smart Contract Studio</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/solc@0.8.21/soljson.js"></script>
</head>
<body class="bg-dark text-light p-4">
  <div class="container">
    <h1 class="text-center mb-4">⚙️ SadiCoin Smart Contract Studio</h1>
    <div id="status" class="alert alert-secondary text-center">⏳ Loading Solidity compiler...</div>

    <!-- Wallet -->
    <div class="text-center mb-3">
      <button id="connectBtn" class="btn btn-success">🔗 Connect Wallet</button>
      <span id="walletAddress" class="ms-2"></span>
    </div>

    <!-- Solidity Code -->
    <textarea id="code" class="form-control bg-black text-success" rows="10">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract SadiCoin is ERC20 {
    constructor(uint256 initialSupply) ERC20("SadiCoin", "SADC") {
        _mint(msg.sender, initialSupply);
    }
}
    </textarea>

    <div class="mt-3 text-center">
      <button class="btn btn-warning" onclick="compileContract()">🧩 Compile</button>
      <button class="btn btn-primary" onclick="deployContract()">🚀 Deploy</button>
    </div>

    <div class="mt-4">
      <h4>📄 ABI</h4>
      <pre id="abiBox" class="bg-black p-2 text-success"></pre>

      <h4>💾 Bytecode</h4>
      <pre id="bytecodeBox" class="bg-black p-2 text-info"></pre>

      <h4>🏷️ Contract Address</h4>
      <pre id="addressBox" class="bg-black p-2 text-warning"></pre>
    </div>
  </div>

<script>
let web3, accounts, abi, bytecode, contractName, sourceCode, deployedAddress;

// ✅ Detect Solidity compiler
window.addEventListener('load', () => {
  const check = setInterval(() => {
    if (window.Module && window.Module.compile) {
      clearInterval(check);
      document.getElementById('status').textContent = "✅ Solidity compiler ready!";
      document.getElementById('status').className = "alert alert-success text-center";
    }
  }, 500);
});

// ✅ Wallet connect (MetaMask, OKX, WalletConnect)
async function connectWallet() {
  try {
    if (window.ethereum) {
      web3 = new Web3(window.ethereum);
      await window.ethereum.request({ method: 'eth_requestAccounts' });
    } else if (window.WalletConnectProvider) {
      const provider = new WalletConnectProvider.default({
        rpc: { 1: "https://mainnet.infura.io/v3/YOUR_INFURA_KEY", 5: "https://goerli.infura.io/v3/YOUR_INFURA_KEY" }
      });
      await provider.enable();
      web3 = new Web3(provider);
    } else {
      return alert("No compatible wallet detected. Install MetaMask or use WalletConnect.");
    }

    accounts = await web3.eth.getAccounts();
    if (!accounts || accounts.length === 0) return alert("No wallet accounts found");
    document.getElementById('walletAddress').textContent = accounts[0];

    if (window.ethereum) {
      window.ethereum.on('accountsChanged', function(accs){
        accounts = accs;
        document.getElementById('walletAddress').textContent = accounts[0] || 'Not connected';
      });
    }
  } catch (err) {
    console.error(err);
    alert("Wallet connection failed: " + err.message);
  }
}
document.getElementById('connectBtn').addEventListener('click', connectWallet);

// ✅ Compile Solidity contract
async function compileContract() {
  try {
    sourceCode = document.getElementById("code").value;
    const solcReady = window.Module;
    const input = {
      language: "Solidity",
      sources: { "Contract.sol": { content: sourceCode } },
      settings: { outputSelection: { "*": { "*": ["abi","evm.bytecode.object"] } } }
    };

    const output = JSON.parse(solcReady.compile(JSON.stringify(input)));
    if (output.errors) {
      const errors = output.errors.filter(e => e.severity === "error");
      if (errors.length) throw new Error(errors.map(e => e.formattedMessage).join("\n"));
    }

    const contractData = output.contracts["Contract.sol"];
    contractName = Object.keys(contractData)[0];
    abi = contractData[contractName].abi;
    bytecode = contractData[contractName].evm.bytecode.object;

    document.getElementById("abiBox").innerText = JSON.stringify(abi, null, 2);
    document.getElementById("bytecodeBox").innerText = bytecode;
    alert("✅ Compiled successfully: " + contractName);
  } catch (err) {
    alert("❌ Compile failed: " + err.message);
  }
}

// ✅ Deploy contract
async function deployContract() {
  if (!web3 || !accounts) return alert("⚠️ Connect wallet first.");
  if (!abi || !bytecode) return alert("⚠️ Compile the contract first.");

  try {
    const contract = new web3.eth.Contract(abi);
    const initialSupply = web3.utils.toWei('1000000000', 'ether'); // 1,000,000,000 SADC
    const deployTx = contract.deploy({ data: "0x" + bytecode, arguments: [initialSupply] });
    const gasEstimate = await deployTx.estimateGas({ from: accounts[0] });
    const deployed = await deployTx.send({ from: accounts[0], gas: gasEstimate });
    deployedAddress = deployed.options.address;

    document.getElementById("addressBox").innerText = deployedAddress;
    alert("✅ Deployed successfully: " + deployedAddress);
  } catch (err) {
    console.error(err);
    alert("❌ Deploy failed: " + err.message);
  }
}
</script>
</body>
</html>

